#ifndef MODEL_SPIRIT_H
#define MODEL_SPIRIT_H


#include "Material"
#include "Spirit"

namespace gl
{

class BaseModelSpirit {
public:
	static shared_ptr<BaseModelSpirit> getModelSpirit(const shared_ptr<Spirit>& p_spirit) {
		return shared_ptr<BaseModelSpirit>(new BaseModelSpirit(p_spirit));
	}

	virtual Spirit& spirit() {
		return *spirit_ptr;
	}

	virtual const shared_ptr<Spirit>& getSpiritPtr() {
		return spirit_ptr;
	}

	virtual void setupUniforms(const shared_ptr<GLShader>& shader_ptr) const {}

protected:
	BaseModelSpirit(const shared_ptr<Spirit>& p_spirit): spirit_ptr{p_spirit} {}

protected:
	shared_ptr<Spirit> spirit_ptr;
};

class StandardModelSpirit: public BaseModelSpirit {
public:
	static shared_ptr<StandardModelSpirit> getModelSpirit(const shared_ptr<Spirit>& p_spirit_ptr, GLuint p_texture_id,
	        const PhoneMaterial& p_material)
	{
		return shared_ptr<StandardModelSpirit>(new StandardModelSpirit(p_spirit_ptr, p_texture_id, p_material));
	}

	virtual void setupUniforms(const shared_ptr<GLShader>& shader_ptr) const {
		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, texture_id);
		glUniform1i(shader_ptr->getUniform("texture_in"), 0);

		material.setUniforms(shader_ptr);
	}

protected:
	StandardModelSpirit(const shared_ptr<Spirit>& p_spirit_ptr, GLuint p_texture_id, const PhoneMaterial& p_material):
		BaseModelSpirit{p_spirit_ptr}, texture_id{p_texture_id}, material{p_material} {}

protected:
	GLuint texture_id;
	const PhoneMaterial& material;
};

class NormalMappingModelSpirit: public StandardModelSpirit {
public:
	static shared_ptr<NormalMappingModelSpirit> getModelSpirit(const shared_ptr<Spirit>& p_spirit_ptr, GLuint p_diffuse_id,
	        GLuint p_normal_id, GLuint p_specular_id, const PhoneMaterial& p_material)
	{
		return shared_ptr<NormalMappingModelSpirit>(new NormalMappingModelSpirit(p_spirit_ptr, p_diffuse_id, p_normal_id,
		        p_specular_id, p_material));
	}

	virtual void setupUniforms(const shared_ptr<GLShader>& shader_ptr) const {
		material.setUniforms(shader_ptr);

		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, texture_id);
		glUniform1i(shader_ptr->getUniform("diffuse_texture"), 0);

		glActiveTexture(GL_TEXTURE1);
		glBindTexture(GL_TEXTURE_2D, normal_id);
		glUniform1i(shader_ptr->getUniform("normal_texture"), 1);

		glActiveTexture(GL_TEXTURE2);
		glBindTexture(GL_TEXTURE_2D, specular_id);
		glUniform1i(shader_ptr->getUniform("specular_texture"), 2);

	}

protected:
	NormalMappingModelSpirit(const shared_ptr<Spirit>& p_spirit_ptr, GLuint p_diffuse_id, GLuint p_normal_id, GLuint p_specular_id,
	                         const PhoneMaterial& p_material):
		StandardModelSpirit{p_spirit_ptr, p_diffuse_id, p_material}, normal_id{p_normal_id}, specular_id{p_specular_id} {}

protected:
	GLuint normal_id, specular_id;
};

class PassthroughMvpModelSpirit: public BaseModelSpirit {
public:
	static shared_ptr<PassthroughMvpModelSpirit> getModelSpirit(const shared_ptr<Spirit>& p_spirit_ptr, const vec4& p_color)
	{
		return shared_ptr<PassthroughMvpModelSpirit>(new PassthroughMvpModelSpirit(p_spirit_ptr, p_color));
	}

	virtual void setColor(const vec4& p_color) {
		color = p_color;
	}

	virtual void setupUniforms(const shared_ptr<GLShader>& shader_ptr) const {
		glUniform4fv(shader_ptr->getUniform("COLOR"), 1, &color[0]);
	}

protected:
	PassthroughMvpModelSpirit(const shared_ptr<Spirit>& p_spirit_ptr, const vec4& p_color):
		BaseModelSpirit{p_spirit_ptr}, color{p_color} {}

protected:
	vec4 color;
};

class ParticleModelSpirit: public PassthroughMvpModelSpirit {
public:
	static shared_ptr<ParticleModelSpirit> getModelSpirit(const shared_ptr<ParticleSpirit>& p_spirit_ptr, const vec4& p_color)
	{
		return shared_ptr<ParticleModelSpirit>(new ParticleModelSpirit(p_spirit_ptr, p_color));
	}

	virtual const vec4& getColor() {
		return color;
	}

	virtual void setupUniforms(const shared_ptr<GLShader>& shader_ptr) const {
		glUniform4fv(shader_ptr->getUniform("COLOR"), 1, &color[0]);
	}

protected:
	ParticleModelSpirit(const shared_ptr<ParticleSpirit>& p_spirit_ptr, const vec4& p_color):
		PassthroughMvpModelSpirit{p_spirit_ptr, p_color} {}
};

}

#endif