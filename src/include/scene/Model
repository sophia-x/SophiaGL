#ifndef MODEL_H
#define MODEL_H

#include <gl_objs/GLObj>
#include <gl_objs/GLShader>

#include "ModelSpirit"

namespace gl
{

class Model {
public:
	virtual ~Model() {}

	virtual void addSpirit(const shared_ptr<BaseModelSpirit>& spirit) {
		spirits.push_back(spirit);
	}

	virtual void update(float delta) {
		for (shared_ptr<BaseModelSpirit>& spirit_ptr : spirits)
			spirit_ptr->spirit().update(delta);
	}

	virtual const void* getData(const string& key, size_t& length) const {
		return gl_obj->getData(key, length);
	};

	virtual	void setData(const string& key, void* data, size_t size) {
		gl_obj->setData(key, data, size);
	}

	virtual const vector<shared_ptr<BaseModelSpirit>>& getSpirits() const {
		return spirits;
	}

	virtual void bufferData(const vector<string>& keys) const {
		gl_obj->bufferData(keys);
	}

	virtual const GLObj& getGLObj() const {
		return *gl_obj;
	}

	virtual const shared_ptr<GLObj>& getGLObjPtr() const {
		return gl_obj;
	}

	virtual void setGLObj(const shared_ptr<GLObj>& p_obj) {
		gl_obj = p_obj;
	}

	virtual void draw(const shared_ptr<GLShader>& shader_ptr) const = 0;

protected:
	Model(const shared_ptr<GLObj>& p_obj, const vector<string>& p_draw_vec, const string& p_draw_obj): gl_obj{p_obj}, draw_vec{p_draw_vec},
		draw_obj{p_draw_obj} {}

protected:
	shared_ptr<GLObj> gl_obj;

	vector<shared_ptr<BaseModelSpirit>> spirits;

	vector<string> draw_vec;
	string draw_obj;
};

class StandardModel: public Model {
public:
	static shared_ptr<StandardModel> getModel(const string& obj_path, const vector<pair<string, string>>& p_textures);

	virtual void draw(const shared_ptr<GLShader>& shader_ptr) const;

protected:
	StandardModel(const shared_ptr<GLObj>& p_obj, const vector<string>& p_draw_vec, const string& p_draw_obj):
		Model{p_obj, p_draw_vec, p_draw_obj} {}
};

class NormalMappingModel: public Model {
public:
	static shared_ptr<NormalMappingModel> getModel(const string& obj_path, const vector<pair<string, string>>& p_textures);

	virtual void draw(const shared_ptr<GLShader>& shader_ptr) const;

protected:
	NormalMappingModel(const shared_ptr<GLObj>& p_obj, const vector<string>& p_draw_vec, const string& p_draw_obj):
		Model{p_obj, p_draw_vec, p_draw_obj} {}
};

class ToolModel: public Model {
public:
	virtual ~ToolModel() {}
	virtual void draw() = 0;

protected:
	ToolModel(const shared_ptr<GLObj>& p_obj, const shared_ptr<GLShader>& p_shader, const vec4& p_border, const vector<string>& p_draw_vec,
	          const string& p_draw_obj): Model{p_obj, p_draw_vec, p_draw_obj}, shader_ptr{p_shader}, border{p_border} {}

private:
	void draw(const shared_ptr<GLShader>& shader_ptr) const {}
protected:
	shared_ptr<GLShader> shader_ptr;
	vec4 border;
};

class TextToolModel: public ToolModel {
public:
	static shared_ptr<TextToolModel> getTool(const vec4& p_border, const vec2& p_size, const string& texture_path = "textures/Holstein.DDS",
	        const string &vertex_path = "shaders/TextVertexShader.vertexshader",
	        const string &fragment_path = "shaders/TextVertexShader.fragmentshader",
	const vector<string>& uniforms = vector<string> {
		"half_width",
		"half_height",
		"texture_in"
	});

	virtual ~TextToolModel() {}

	virtual void print_text(const string& text, int x, int y, int size);

	virtual void clear() {
		gl_obj->setData("Vertices", 0, 0);
		gl_obj->setData("Uvs", 0, 0);

		change = true;
	}

	virtual void draw();

protected:
	TextToolModel(const shared_ptr<GLObj>& p_obj, const shared_ptr<GLShader>& p_shader, const vec4& p_border, const vec2& p_size,
	              const vector<string>& p_draw_vec, const string& p_draw_obj):
		ToolModel{p_obj, p_shader, p_border, p_draw_vec, p_draw_obj}, size{p_size}, change{false} {}

private:
	vec2 size;
	bool change;
};

class PassthroughMvpToolModel: public ToolModel {
public:
	static shared_ptr<PassthroughMvpToolModel> getTool(const vec4& p_border, GLenum p_mode, bool use_index = false,
	        const string &vertex_path = "shaders/PassthroughMVP.vertexshader",
	        const string &fragment_path = "shaders/PassthroughMVP.fragmentshader",
	const vector<string>& uniforms = vector<string> {
		"COLOR",
		"MVP"
	});

	virtual ~PassthroughMvpToolModel() {}

	virtual void draw();

protected:
	PassthroughMvpToolModel(const shared_ptr<GLObj>& p_obj, const shared_ptr<GLShader>& p_shader, const vec4& p_border, GLenum p_mode,
	                        const vector<string>& p_draw_vec, const string& p_draw_obj):
		ToolModel{p_obj, p_shader, p_border, p_draw_vec, p_draw_obj}, mode{p_mode} {}

private:
	GLenum mode;
};

class VertexColorToolModel: public ToolModel {
public:
	static shared_ptr<VertexColorToolModel> getTool(const vec4& p_border, GLenum p_mode,
	        const string &vertex_path = "shaders/Transform.vertexshader",
	        const string &fragment_path = "shaders/Color.fragmentshader",
	const vector<string>& uniforms = vector<string> {
		"MVP"
	});

	virtual ~VertexColorToolModel() {}

	virtual void draw();

protected:
	VertexColorToolModel(const shared_ptr<GLObj>& p_obj, const shared_ptr<GLShader>& p_shader, const vec4& p_border, GLenum p_mode,
	                     const vector<string>& p_draw_vec, const string& p_draw_obj): ToolModel{p_obj, p_shader, p_border,
		                             p_draw_vec, p_draw_obj}, mode{p_mode} {}

private:
	GLenum mode;
};

class BillboardToolModel: public ToolModel {
public:
	static shared_ptr<BillboardToolModel> getTool(const vec4& p_border, const vec4& p_board_border, const vec4& p_life_color, GLenum mode,
	        const string& p_texture = "textures/billboard.DDS", const string &vertex_path = "shaders/Billboard_2D.vertexshader",
	        const string &fragment_path = "shaders/Billboard.fragmentshader",
	const vector<string>& uniforms = vector<string> {
		"texture_in",
		"border",
		"life_color",
		"camera_right_worldspace",
		"camera_up_worldspace",
		"VP",
		"billboard_pos",
		"billboard_size"
	});

	virtual ~BillboardToolModel() {}

	virtual void draw();

protected:
	BillboardToolModel(const shared_ptr<GLObj>& p_obj, const shared_ptr<GLShader>& p_shader, const vec4& p_border, const vec4& p_board_border,
	                   const vec4& p_life_color, const vector<string>& p_draw_vec, const string& p_draw_obj):
		ToolModel{p_obj, p_shader, p_border, p_draw_vec, p_draw_obj}, board_border{p_board_border}, life_color{p_life_color} {}

protected:
	vec4 board_border;
	vec4 life_color;
};

}

#endif