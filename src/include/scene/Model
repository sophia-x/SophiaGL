#ifndef MODEL_H
#define MODEL_H

#include <gl_objs/GLObj>
#include <gl_objs/GLShader>

#include "Material"

namespace gl
{

class Setter {
public:
	static const shared_ptr<Setter> getSetter() {
		return shared_ptr<Setter>(new Setter());
	}

	virtual void update(float delta) {}

	virtual void setup() const {}

protected:
	Setter() {}
	Setter(const shared_ptr<Setter>& p_setter_ptr): setter_ptr{p_setter_ptr} {}

	shared_ptr<Setter> setter_ptr;
};

class TimeSetter: public Setter {
public:
	static shared_ptr<TimeSetter> getSetter(const shared_ptr<Setter>& p_setter_ptr, GLuint p_time_id) {
		return shared_ptr<TimeSetter>(new TimeSetter(p_setter_ptr, p_time_id));
	}

	virtual void update(float delta) {
		setter_ptr->update(delta);
	}

	virtual void setup() const {
		glUniform1f(time_id, glfwGetTime());
		setter_ptr->setup();
	}

protected:
	TimeSetter(const shared_ptr<Setter>& p_setter_ptr, GLuint p_time_id): Setter{p_setter_ptr}, time_id{p_time_id} {}

	GLuint time_id;
};

class Model {
public:
	virtual ~Model() {}

	virtual void update(float delta) {
		setter->update(delta);
	}

	virtual const void* getData(const string& key, size_t& length) const {
		return gl_obj->getData(key, length);
	};

	virtual	void setData(const string& key, void* data, size_t size) {
		gl_obj->setData(key, data, size);
	}

	virtual void bufferData(const vector<string>& keys) const {
		gl_obj->bufferData(keys);
	}

	virtual const GLObj& getGLObj() const {
		return *gl_obj;
	}

	virtual void setSetter(const shared_ptr<Setter>& p_setter) {
		setter = p_setter;
	}

	virtual const shared_ptr<GLObj>& getGLObjPtr() const {
		return gl_obj;
	}

	virtual void setGLObj(const shared_ptr<GLObj>& p_obj) {
		gl_obj = p_obj;
	}

	virtual const shared_ptr<GLShader>& getShaderPtr() const {
		return shader_ptr;
	}

	virtual const shared_ptr<Spirit>& spirit_ptr() const {
		return spirit;
	}

	virtual void draw() const = 0;

protected:
	Model(const shared_ptr<GLObj>& p_obj, const shared_ptr<GLShader>& p_shader, const vector<string>& p_draw_vec, const string& p_draw_obj,
	      const shared_ptr<Setter>& p_setter_ptr): gl_obj{p_obj}, shader_ptr{p_shader}, draw_vec{p_draw_vec}, draw_obj{p_draw_obj},
		setter{p_setter_ptr} {}
	Model(const shared_ptr<GLObj>& p_obj, const shared_ptr<GLShader>& p_shader, const shared_ptr<Spirit>& p_spirit,
	      const vector<string>& p_draw_vec, const string& p_draw_obj, const shared_ptr<Setter>& p_setter_ptr): gl_obj{p_obj},
		shader_ptr{p_shader}, spirit{p_spirit}, draw_vec{p_draw_vec}, draw_obj{p_draw_obj}, setter{p_setter_ptr} {}
	Model(const shared_ptr<GLObj>& p_obj);

protected:
	shared_ptr<GLObj> gl_obj;
	shared_ptr<GLShader> shader_ptr;

	vector<string> draw_vec;
	string draw_obj;

	shared_ptr<Spirit> spirit;

	shared_ptr<Setter> setter;
};

class SetterModel: public Model {
public:
	static shared_ptr<SetterModel> initModel(const shared_ptr<GLObj>& p_obj) {
		return shared_ptr<SetterModel>(new SetterModel(p_obj));
	}

	shared_ptr<SetterModel> getInstance(const shared_ptr<Spirit>& p_spirit) {
		return shared_ptr<SetterModel>(new SetterModel(gl_obj, shader_ptr, draw_vec, draw_obj, p_spirit, setter));
	}

	shared_ptr<SetterModel> getInstance(const shared_ptr<Spirit>& p_spirit, const shared_ptr<Setter>& p_setter_ptr) {
		return shared_ptr<SetterModel>(new SetterModel(gl_obj, shader_ptr, draw_vec, draw_obj, p_spirit, p_setter_ptr));
	}

	virtual void draw() const {
		shader_ptr->useShader(); {
			setter->setup();
			gl_obj->draw(draw_vec, draw_obj);
		} shader_ptr->unuseShader();
	}

protected:
	SetterModel(const shared_ptr<GLObj>& p_obj): Model{p_obj} {}

	SetterModel(const shared_ptr<GLObj>& p_obj, const shared_ptr<GLShader>& p_shader, const vector<string>& p_draw_vec,
	            const string& p_draw_obj, const shared_ptr<Spirit>& p_spirit, const shared_ptr<Setter>& p_setter_ptr):
		Model{p_obj, p_shader, p_spirit, p_draw_vec, p_draw_obj, p_setter_ptr} {}
};

class StandardModel: public Model {
public:
	static shared_ptr<StandardModel> initModel(const string & obj_path, const vector<pair<string, string>> & p_textures,
	        const string & vertex_path = "shaders/StandardShading.vertexshader",
	        const string & fragment_path = "shaders/StandardShading.fragmentshader",
	const vector<string> & uniforms = vector<string> {
		"MVP",
		"V",
		"M",
		"light_position_worldspace",
		"diffuse_texture",
		"light_color",
		"light_power",
		"material_ambient_color_ratio",
		"material_specular_color",
		"material_specular_ratio"
	});

	virtual shared_ptr<StandardModel> getInstance(const shared_ptr<Spirit>& p_spirit, GLuint p_texture_id, const PhoneMaterial* p_material) const {
		return shared_ptr<StandardModel>(new StandardModel(gl_obj, shader_ptr, draw_vec, draw_obj, p_spirit, setter, p_texture_id, p_material));
	}

	virtual void draw() const;

protected:
	StandardModel(const shared_ptr<GLObj>& p_obj, const shared_ptr<GLShader>& p_shader, const vector<string>& p_draw_vec,
	              const string& p_draw_obj): Model{p_obj, p_shader, p_draw_vec, p_draw_obj, Setter::getSetter()} {}
	StandardModel(const shared_ptr<GLObj>& p_obj, const shared_ptr<GLShader>& p_shader, const vector<string>& p_draw_vec,
	              const string& p_draw_obj, const shared_ptr<Spirit>& p_spirit, const shared_ptr<Setter>& p_setter_ptr, GLuint p_texture_id,
	              const PhoneMaterial* p_material): Model{p_obj, p_shader, p_spirit, p_draw_vec, p_draw_obj, p_setter_ptr},
		texture_id{p_texture_id}, material{p_material} {}

protected:
	GLuint texture_id;
	const PhoneMaterial* material;
};

class ShadowMapModel: public Model {
public:
	static shared_ptr<ShadowMapModel> getModel(const shared_ptr<GLObj>& p_obj, const shared_ptr<GLShader>& p_shader,
	        const shared_ptr<Spirit>& p_spirit) {
		return shared_ptr<ShadowMapModel>(new ShadowMapModel(p_obj, p_shader, p_spirit, vector<string> {"Vertices", "Indices"}, "Element"));
	}

	virtual void draw() const {
		glUniformMatrix4fv(shader_ptr->getUniform("M"), 1, GL_FALSE, &(spirit->getModelMatrix()[0][0]));
		gl_obj->draw(draw_vec, draw_obj);
	}

protected:
	ShadowMapModel(const shared_ptr<GLObj>& p_obj, const shared_ptr<GLShader>& p_shader, const shared_ptr<Spirit>& p_spirit, const
	               vector<string>& p_draw_vec, const string& p_draw_obj): Model{p_obj, p_shader, p_spirit, p_draw_vec, p_draw_obj, Setter::getSetter()} {}
};

class NormalMappingModel: public StandardModel {
public:
	static shared_ptr<NormalMappingModel> initModel(const string& obj_path, const vector<pair<string, string>>& p_textures,
	        const string &vertex_path = "shaders/NormalMapping.vertexshader",
	        const string &fragment_path = "shaders/NormalMapping.fragmentshader",
	const vector<string>& uniforms = vector<string> {
		"diffuse_texture",
		"normal_texture",
		"specular_texture",
		"MVP",
		"V",
		"M",
		"MV3x3",
		"light_position_worldspace",
		"light_color",
		"light_power",
		"material_ambient_color_ratio",
		"material_specular_color",
		"material_specular_ratio"
	});

	virtual shared_ptr<NormalMappingModel> getInstance(const shared_ptr<Spirit>& p_spirit, GLuint p_texture_id, GLuint p_normal_id,
	        GLuint p_specular_id, const PhoneMaterial* p_material) const {
		return shared_ptr<NormalMappingModel>(new NormalMappingModel(gl_obj, shader_ptr, draw_vec, draw_obj, setter, p_spirit, p_texture_id,
		                                      p_normal_id, p_specular_id, p_material));
	}

	virtual void draw() const;

protected:
	NormalMappingModel(const shared_ptr<GLObj>& p_obj, const shared_ptr<GLShader>& p_shader, const vector<string>& p_draw_vec,
	                   const string& p_draw_obj): StandardModel{p_obj, p_shader, p_draw_vec, p_draw_obj} {}
	NormalMappingModel(const shared_ptr<GLObj>& p_obj, const shared_ptr<GLShader>& p_shader, const vector<string>& p_draw_vec,
	                   const string& p_draw_obj, const shared_ptr<Setter>& p_setter_ptr, const shared_ptr<Spirit>& p_spirit, GLuint p_texture_id, GLuint p_normal_id,
	                   GLuint p_specular_id, const PhoneMaterial* p_material): StandardModel{p_obj, p_shader, p_draw_vec, p_draw_obj, p_spirit, p_setter_ptr,
		                           p_texture_id, p_material}, normal_id{p_normal_id}, specular_id{p_specular_id} {}

protected:
	GLuint normal_id, specular_id;
};

class ToolModel: public Model {
public:
	virtual ~ToolModel() {}

protected:
	ToolModel(const shared_ptr<GLObj>& p_obj, const shared_ptr<GLShader>& p_shader, const vec4& p_border, const vector<string>& p_draw_vec,
	          const string& p_draw_obj, const shared_ptr<Setter>& p_setter_ptr): Model{p_obj, p_shader, p_draw_vec, p_draw_obj, p_setter_ptr}, border{p_border} {}
	ToolModel(const shared_ptr<GLObj>& p_obj, const shared_ptr<GLShader>& p_shader, const shared_ptr<Spirit>& p_spirit, const vec4& p_border,
	          const vector<string>& p_draw_vec, const string& p_draw_obj, const shared_ptr<Setter>& p_setter_ptr): Model{p_obj, p_shader, p_spirit, p_draw_vec, p_draw_obj, p_setter_ptr},
		border{p_border} {}
protected:
	vec4 border;
};

class TextToolModel: public ToolModel {
public:
	static shared_ptr<TextToolModel> initTool(const vec4& p_border, const vec2& p_size, const string& texture_path = "textures/Holstein.DDS",
	        const string &vertex_path = "shaders/TextVertexShader.vertexshader",
	        const string &fragment_path = "shaders/TextVertexShader.fragmentshader",
	const vector<string>& uniforms = vector<string> {
		"half_width",
		"half_height",
		"texture_in"
	});

	virtual ~TextToolModel() {}

	virtual void print_text(const string& text, int x, int y, int size);

	virtual void flush() {
		if (change) {
			gl_obj->bufferData(vector<string> {"Vertices", "Uvs"});
			change = false;
		}
	}

	virtual void clear() {
		gl_obj->setData("Vertices", 0, 0);
		gl_obj->setData("Uvs", 0, 0);

		change = true;
	}

	virtual void draw() const;

protected:
	TextToolModel(const shared_ptr<GLObj>& p_obj, const shared_ptr<GLShader>& p_shader, const vec4& p_border, const vec2& p_size,
	              const vector<string>& p_draw_vec, const string& p_draw_obj):
		ToolModel{p_obj, p_shader, p_border, p_draw_vec, p_draw_obj, Setter::getSetter()}, size{p_size}, change{false} {}

private:
	vec2 size;
	bool change;
};

class PassthroughMvpToolModel: public ToolModel {
public:
	static shared_ptr<PassthroughMvpToolModel> initTool(const vec4& p_border, GLenum p_mode, const vec4& p_color, bool use_index = false,
	        const string &vertex_path = "shaders/PassthroughMVP.vertexshader",
	        const string &fragment_path = "shaders/PassthroughMVP.fragmentshader",
	const vector<string>& uniforms = vector<string> {
		"COLOR",
		"MVP"
	});

	virtual shared_ptr<PassthroughMvpToolModel> getInstance(const shared_ptr<Spirit>& p_spirit) const {
		return shared_ptr<PassthroughMvpToolModel>(new PassthroughMvpToolModel(gl_obj, shader_ptr, border, mode,
		        color, p_spirit, draw_vec, draw_obj, setter));
	}

	virtual ~PassthroughMvpToolModel() {}

	virtual void setColor(const vec4& p_color) {
		color = p_color;
	}

	virtual void draw() const;

protected:
	PassthroughMvpToolModel(const shared_ptr<GLObj>& p_obj, const shared_ptr<GLShader>& p_shader, const vec4& p_border, GLenum p_mode,
	                        const vec4& p_color, const vector<string>& p_draw_vec, const string& p_draw_obj):
		ToolModel{p_obj, p_shader, p_border, p_draw_vec, p_draw_obj, Setter::getSetter()}, mode{p_mode}, color{p_color} {}

	PassthroughMvpToolModel(const shared_ptr<GLObj>& p_obj, const shared_ptr<GLShader>& p_shader, const vec4& p_border, GLenum p_mode, const
	                        vec4& p_color, const shared_ptr<Spirit>& p_spirit , const vector<string>& p_draw_vec, const string& p_draw_obj, const shared_ptr<Setter>& p_setter_ptr):
		ToolModel{p_obj, p_shader, p_spirit, p_border, p_draw_vec, p_draw_obj, p_setter_ptr}, mode{p_mode}, color{p_color} {}

private:
	GLenum mode;

	vec4 color;
};

class VertexColorToolModel: public ToolModel {
public:
	static shared_ptr<VertexColorToolModel> initTool(const vec4& p_border, GLenum p_mode,
	        const string &vertex_path = "shaders/Transform.vertexshader",
	        const string &fragment_path = "shaders/Color.fragmentshader",
	const vector<string>& uniforms = vector<string> {
		"MVP"
	});

	virtual shared_ptr<VertexColorToolModel> getInstance(const shared_ptr<Spirit>& p_spirit) const {
		return shared_ptr<VertexColorToolModel>(new VertexColorToolModel(gl_obj, shader_ptr, border, mode, p_spirit, draw_vec, draw_obj, setter));
	}

	virtual ~VertexColorToolModel() {}

	virtual void draw() const;

protected:
	VertexColorToolModel(const shared_ptr<GLObj>& p_obj, const shared_ptr<GLShader>& p_shader, const vec4& p_border, GLenum p_mode,
	                     const vector<string>& p_draw_vec, const string& p_draw_obj): ToolModel{p_obj, p_shader, p_border,
		                             p_draw_vec, p_draw_obj, Setter::getSetter()}, mode{p_mode} {}
	VertexColorToolModel(const shared_ptr<GLObj>& p_obj, const shared_ptr<GLShader>& p_shader, const vec4& p_border, GLenum p_mode,
	                     const shared_ptr<Spirit>& p_spirit, const vector<string>& p_draw_vec, const string& p_draw_obj, const shared_ptr<Setter>& p_setter_ptr):
		ToolModel{p_obj, p_shader, p_spirit, p_border, p_draw_vec, p_draw_obj, p_setter_ptr}, mode{p_mode} {}
private:
	GLenum mode;
};

class VertexTextureToolModel: public ToolModel {
public:
	static shared_ptr<VertexTextureToolModel> initTool(const vec4& p_border, GLenum p_mode, GLuint texture_id,
	        const string &vertex_path = "shaders/Passthrough.vertexshader",
	        const string &fragment_path = "shaders/Passthrough.fragmentshader",
	const vector<string>& uniforms = vector<string> {
		"texture_in",
		"M"
	});

	virtual ~VertexTextureToolModel() {}

	virtual shared_ptr<VertexTextureToolModel> getInstance(const shared_ptr<Spirit>& p_spirit) const {
		return shared_ptr<VertexTextureToolModel>(new VertexTextureToolModel(gl_obj, shader_ptr, border, mode, p_spirit, draw_vec, draw_obj, setter));
	}

	virtual void draw() const;

protected:
	VertexTextureToolModel(const shared_ptr<GLObj>& p_obj, const shared_ptr<GLShader>& p_shader, const vec4& p_border, GLenum p_mode,
	                       const vector<string>& p_draw_vec, const string& p_draw_obj): ToolModel{p_obj, p_shader, p_border,
		                               p_draw_vec, p_draw_obj, Setter::getSetter()}, mode{p_mode} {}
	VertexTextureToolModel(const shared_ptr<GLObj>& p_obj, const shared_ptr<GLShader>& p_shader, const vec4& p_border, GLenum p_mode,
	                       const shared_ptr<Spirit>& p_spirit, const vector<string>& p_draw_vec, const string& p_draw_obj, const shared_ptr<Setter>& p_setter_ptr):
		ToolModel{p_obj, p_shader, p_spirit, p_border, p_draw_vec, p_draw_obj, p_setter_ptr}, mode{p_mode} {}

private:
	GLenum mode;
};

class BillboardToolModel: public ToolModel {
public:
	static shared_ptr<BillboardToolModel> initTool(const vec4& p_border, const vec4& p_board_border, const vec4& p_life_color, GLenum mode,
	        const string& p_texture = "textures/billboard.DDS", const string &vertex_path = "shaders/Billboard_2D.vertexshader",
	        const string &fragment_path = "shaders/Billboard.fragmentshader",
	const vector<string>& uniforms = vector<string> {
		"texture_in",
		"border",
		"life_color",
		"camera_right_worldspace",
		"camera_up_worldspace",
		"VP",
		"billboard_pos",
		"billboard_size"
	});

	virtual ~BillboardToolModel() {}

	virtual shared_ptr<BillboardToolModel> getInstance(const shared_ptr<Spirit>& p_spirit) const {
		return shared_ptr<BillboardToolModel>(new BillboardToolModel(gl_obj, shader_ptr, border, board_border,
		                                      life_color, p_spirit, draw_vec, draw_obj, setter));
	}

	virtual void draw() const;

protected:
	BillboardToolModel(const shared_ptr<GLObj>& p_obj, const shared_ptr<GLShader>& p_shader, const vec4& p_border, const vec4& p_board_border,
	                   const vec4& p_life_color, const vector<string>& p_draw_vec, const string& p_draw_obj):
		ToolModel{p_obj, p_shader, p_border, p_draw_vec, p_draw_obj, Setter::getSetter()}, board_border{p_board_border}, life_color{p_life_color} {}
	BillboardToolModel(const shared_ptr<GLObj>& p_obj, const shared_ptr<GLShader>& p_shader, const vec4& p_border, const vec4& p_board_border,
	                   const vec4& p_life_color, const shared_ptr<Spirit>& p_spirit, const vector<string>& p_draw_vec, const string& p_draw_obj, const shared_ptr<Setter>& p_setter_ptr):
		ToolModel{p_obj, p_shader, p_spirit, p_border, p_draw_vec, p_draw_obj, p_setter_ptr}, board_border{p_board_border}, life_color{p_life_color} {}

protected:
	vec4 board_border;
	vec4 life_color;
};

class ParticleToolModel: public ToolModel {
public:
	static shared_ptr<ParticleToolModel> initTool(const vec4& p_border, GLenum mode,
	        const string& p_texture = "textures/Particle.DDS", const string &vertex_path = "shaders/Particle.vertexshader",
	        const string &fragment_path = "shaders/Particle.fragmentshader",
	const vector<string>& uniforms = vector<string> {
		"texture_in",
		"camera_right_worldspace",
		"camera_up_worldspace",
		"vp"
	});

	virtual ~ParticleToolModel() {}

	virtual void addSpirit(const shared_ptr<ParticleSpirit>& spirit) {
		spirits.push_back(spirit);
	}

	virtual void update(float delta);

	virtual void draw() const;

protected:
	ParticleToolModel(const shared_ptr<GLObj>& p_obj, const shared_ptr<GLShader>& p_shader, const vec4& p_border,
	                  const vector<string>& p_draw_vec, const string& p_draw_obj):
		ToolModel{p_obj, p_shader, p_border, p_draw_vec, p_draw_obj, Setter::getSetter()} {}

	virtual void sortByLife();

protected:
	vector<shared_ptr<ParticleSpirit>> spirits;
};

}
#endif